expression 'Errores en Ventas' =
		let
		Origen = Ventas,
		  #"Errores de coincidencia detectados" = let
		    tableWithOnlyPrimitiveTypes = Table.SelectColumns(Origen, Table.ColumnsOfType(Origen, {type nullable number, type nullable text, type nullable logical, type nullable date, type nullable datetime, type nullable datetimezone, type nullable time, type nullable duration})),
		    recordTypeFields = Type.RecordFields(Type.TableRow(Value.Type(tableWithOnlyPrimitiveTypes))),
		    fieldNames = Record.FieldNames(recordTypeFields),
		    fieldTypes = List.Transform(Record.ToList(recordTypeFields), each [Type]),
		    pairs = List.Transform(List.Positions(fieldNames), (i) => {fieldNames{i}, (v) => if v = null or Value.Is(v, fieldTypes{i}) then v else error [Message = "El tipo del valor no coincide con el tipo de la columna.", Detail = v], fieldTypes{i}})
		in
		    Table.TransformColumns(Origen, pairs),
		  #"Índice agregado" = Table.AddIndexColumn(#"Errores de coincidencia detectados", "Número de fila" ,1),
		  #"Conservar errores" = Table.SelectRowsWithErrors(#"Índice agregado", {"ID Canal", "Provincia", "Ciudad", "ID Empresa", "ID Vendedor", "Comprador_Apellido", "Comprador_Nombre", "Tipo Titular", "Voucher", "Fecha de Emisión", "Origen", "ID Destino", "ID Producto", "Tipo de Producto", "Inicio Viaje", "Fin Viaje", "ID Forma de Pago"}),
		  #"Columnas reordenadas" = Table.ReorderColumns(#"Conservar errores", {"Número de fila", "ID Canal", "Provincia", "Ciudad", "ID Empresa", "ID Vendedor", "Comprador_Apellido", "Comprador_Nombre", "Tipo Titular", "Voucher", "Fecha de Emisión", "Origen", "ID Destino", "ID Producto", "Tipo de Producto", "Inicio Viaje", "Fin Viaje", "ID Forma de Pago"})
		in
		  #"Columnas reordenadas"
	lineageTag: cb02876d-388b-4407-b677-c96081709b1b
	queryGroup: 'Errores en las consultas: 12/3/2024 19:51:21'

	annotation PBI_NavigationStepName = Navegación

	annotation PBI_ResultType = Table

expression 'Errores en Ventas (2)' =
		let
		Origen = Ventas,
		  #"Errores de coincidencia detectados" = let
		    tableWithOnlyPrimitiveTypes = Table.SelectColumns(Origen, Table.ColumnsOfType(Origen, {type nullable number, type nullable text, type nullable logical, type nullable date, type nullable datetime, type nullable datetimezone, type nullable time, type nullable duration})),
		    recordTypeFields = Type.RecordFields(Type.TableRow(Value.Type(tableWithOnlyPrimitiveTypes))),
		    fieldNames = Record.FieldNames(recordTypeFields),
		    fieldTypes = List.Transform(Record.ToList(recordTypeFields), each [Type]),
		    pairs = List.Transform(List.Positions(fieldNames), (i) => {fieldNames{i}, (v) => if v = null or Value.Is(v, fieldTypes{i}) then v else error [Message = "El tipo del valor no coincide con el tipo de la columna.", Detail = v], fieldTypes{i}})
		in
		    Table.TransformColumns(Origen, pairs),
		  #"Índice agregado" = Table.AddIndexColumn(#"Errores de coincidencia detectados", "Número de fila" ,1),
		  #"Conservar errores" = Table.SelectRowsWithErrors(#"Índice agregado", {"ID Canal", "Provincia", "Ciudad", "ID Empresa", "ID Vendedor", "Comprador_Apellido", "Comprador_Nombre", "Tipo Titular", "Voucher", "Fecha de Emisión", "Origen", "ID Destino", "ID Producto", "Tipo de Producto", "Inicio Viaje", "Fin Viaje", "ID Forma de Pago"}),
		  #"Columnas reordenadas" = Table.ReorderColumns(#"Conservar errores", {"Número de fila", "ID Canal", "Provincia", "Ciudad", "ID Empresa", "ID Vendedor", "Comprador_Apellido", "Comprador_Nombre", "Tipo Titular", "Voucher", "Fecha de Emisión", "Origen", "ID Destino", "ID Producto", "Tipo de Producto", "Inicio Viaje", "Fin Viaje", "ID Forma de Pago"})
		in
		  #"Columnas reordenadas"
	lineageTag: 8b009262-45b7-47f7-abd5-6aac796a1b6a
	queryGroup: 'Errores en las consultas: 12/3/2024 19:56:36'

	annotation PBI_ResultType = Table

expression Consulta1 =
		let
		    Origen = DateTime.LocalNow
		in
		    Origen
	lineageTag: 617bde37-254e-43f3-8a37-a8fe390e585a

	annotation PBI_NavigationStepName = Navegación

	annotation PBI_ResultType = Function

